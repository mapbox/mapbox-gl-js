// @ts-expect-error - GLSL import
import preludeCommon from './_prelude.glsl';
// @ts-expect-error - GLSL import
import preludeFrag from './_prelude.fragment.glsl';
// @ts-expect-error - GLSL import
import preludeVert from './_prelude.vertex.glsl';
// @ts-expect-error - GLSL import
import backgroundFrag from './background.fragment.glsl';
// @ts-expect-error - GLSL import
import backgroundVert from './background.vertex.glsl';
// @ts-expect-error - GLSL import
import backgroundPatternFrag from './background_pattern.fragment.glsl';
// @ts-expect-error - GLSL import
import backgroundPatternVert from './background_pattern.vertex.glsl';
// @ts-expect-error - GLSL import
import buildingFrag from '../../3d-style/shaders/building.fragment.glsl';
// @ts-expect-error - GLSL import
import buildingVert from '../../3d-style/shaders/building.vertex.glsl';
// @ts-expect-error - GLSL import
import buildingDepthFrag from '../../3d-style/shaders/building_depth.fragment.glsl';
// @ts-expect-error - GLSL import
import buildingDepthVert from '../../3d-style/shaders/building_depth.vertex.glsl';
// @ts-expect-error - GLSL import
import circleFrag from './circle.fragment.glsl';
// @ts-expect-error - GLSL import
import circleVert from './circle.vertex.glsl';
// @ts-expect-error - GLSL import
import clippingMaskFrag from './clipping_mask.fragment.glsl';
// @ts-expect-error - GLSL import
import clippingMaskVert from './clipping_mask.vertex.glsl';
// @ts-expect-error - GLSL import
import heatmapFrag from './heatmap.fragment.glsl';
// @ts-expect-error - GLSL import
import heatmapVert from './heatmap.vertex.glsl';
// @ts-expect-error - GLSL import
import heatmapTextureFrag from './heatmap_texture.fragment.glsl';
// @ts-expect-error - GLSL import
import heatmapTextureVert from './heatmap_texture.vertex.glsl';
// @ts-expect-error - GLSL import
import collisionBoxFrag from './collision_box.fragment.glsl';
// @ts-expect-error - GLSL import
import collisionBoxVert from './collision_box.vertex.glsl';
// @ts-expect-error - GLSL import
import collisionCircleFrag from './collision_circle.fragment.glsl';
// @ts-expect-error - GLSL import
import collisionCircleVert from './collision_circle.vertex.glsl';
// @ts-expect-error - GLSL import
import debugFrag from './debug.fragment.glsl';
// @ts-expect-error - GLSL import
import debugVert from './debug.vertex.glsl';
// @ts-expect-error - GLSL import
import fillFrag from './fill.fragment.glsl';
// @ts-expect-error - GLSL import
import fillVert from './fill.vertex.glsl';
// @ts-expect-error - GLSL import
import fillOutlineFrag from './fill_outline.fragment.glsl';
// @ts-expect-error - GLSL import
import fillOutlineVert from './fill_outline.vertex.glsl';
// @ts-expect-error - GLSL import
import fillOutlinePatternFrag from './fill_outline_pattern.fragment.glsl';
// @ts-expect-error - GLSL import
import fillOutlinePatternVert from './fill_outline_pattern.vertex.glsl';
// @ts-expect-error - GLSL import
import fillPatternFrag from './fill_pattern.fragment.glsl';
// @ts-expect-error - GLSL import
import fillPatternVert from './fill_pattern.vertex.glsl';
// @ts-expect-error - GLSL import
import fillExtrusionFrag from './fill_extrusion.fragment.glsl';
// @ts-expect-error - GLSL import
import fillExtrusionVert from './fill_extrusion.vertex.glsl';
// @ts-expect-error - GLSL import
import fillExtrusionPatternFrag from './fill_extrusion_pattern.fragment.glsl';
// @ts-expect-error - GLSL import
import fillExtrusionPatternVert from './fill_extrusion_pattern.vertex.glsl';
// @ts-expect-error - GLSL import
import hillshadePrepareFrag from './hillshade_prepare.fragment.glsl';
// @ts-expect-error - GLSL import
import fillExtrusionGroundEffectFrag from './fill_extrusion_ground_effect.fragment.glsl';
// @ts-expect-error - GLSL import
import fillExtrusionGroundEffectVert from './fill_extrusion_ground_effect.vertex.glsl';
// @ts-expect-error - GLSL import
import hillshadePrepareVert from './hillshade_prepare.vertex.glsl';
// @ts-expect-error - GLSL import
import hillshadeFrag from './hillshade.fragment.glsl';
// @ts-expect-error - GLSL import
import hillshadeVert from './hillshade.vertex.glsl';
// @ts-expect-error - GLSL import
import lineFrag from './line.fragment.glsl';
// @ts-expect-error - GLSL import
import lineVert from './line.vertex.glsl';
// @ts-expect-error - GLSL import
import linePatternFrag from './line_pattern.fragment.glsl';
// @ts-expect-error - GLSL import
import linePatternVert from './line_pattern.vertex.glsl';
// @ts-expect-error - GLSL import
import rasterFrag from './raster.fragment.glsl';
// @ts-expect-error - GLSL import
import rasterVert from './raster.vertex.glsl';
// @ts-expect-error - GLSL import
import rasterParticleFrag from './raster_particle.fragment.glsl';
// @ts-expect-error - GLSL import
import rasterParticleVert from './raster_particle.vertex.glsl';
// @ts-expect-error - GLSL import
import rasterParticleDrawFrag from './raster_particle_draw.fragment.glsl';
// @ts-expect-error - GLSL import
import rasterParticleDrawVert from './raster_particle_draw.vertex.glsl';
// @ts-expect-error - GLSL import
import rasterParticleTextureFrag from './raster_particle_texture.fragment.glsl';
// @ts-expect-error - GLSL import
import rasterParticleTextureVert from './raster_particle_texture.vertex.glsl';
// @ts-expect-error - GLSL import
import rasterParticleUpdateFrag from './raster_particle_update.fragment.glsl';
// @ts-expect-error - GLSL import
import rasterParticleUpdateVert from './raster_particle_update.vertex.glsl';
// @ts-expect-error - GLSL import
import symbolFrag from './symbol.fragment.glsl';
// @ts-expect-error - GLSL import
import symbolVert from './symbol.vertex.glsl';
// @ts-expect-error - GLSL import
import skyboxFrag from './skybox.fragment.glsl';
// @ts-expect-error - GLSL import
import skyboxGradientFrag from './skybox_gradient.fragment.glsl';
// @ts-expect-error - GLSL import
import skyboxVert from './skybox.vertex.glsl';
// @ts-expect-error - GLSL import
import terrainRasterFrag from './terrain_raster.fragment.glsl';
// @ts-expect-error - GLSL import
import terrainRasterVert from './terrain_raster.vertex.glsl';
// @ts-expect-error - GLSL import
import terrainDepthFrag from './terrain_depth.fragment.glsl';
// @ts-expect-error - GLSL import
import terrainDepthVert from './terrain_depth.vertex.glsl';
// @ts-expect-error - GLSL import
import preludeTerrainVert from './_prelude_terrain.vertex.glsl';
// @ts-expect-error - GLSL import
import preludeFogVert from './_prelude_fog.vertex.glsl';
// @ts-expect-error - GLSL import
import preludeFogFrag from './_prelude_fog.fragment.glsl';
// @ts-expect-error - GLSL import
import preludeLighting from './_prelude_lighting.glsl';
// @ts-expect-error - GLSL import
import preludeRasterArrayFrag from './_prelude_raster_array.glsl';
// @ts-expect-error - GLSL import
import preludeRasterParticleFrag from './_prelude_raster_particle.glsl';
// @ts-expect-error - GLSL import
import skyboxCaptureFrag from './skybox_capture.fragment.glsl';
// @ts-expect-error - GLSL import
import skyboxCaptureVert from './skybox_capture.vertex.glsl';
// @ts-expect-error - GLSL import
import globeFrag from './globe_raster.fragment.glsl';
// @ts-expect-error - GLSL import
import globeVert from './globe_raster.vertex.glsl';
// @ts-expect-error - GLSL import
import atmosphereFrag from './atmosphere.fragment.glsl';
// @ts-expect-error - GLSL import
import atmosphereVert from './atmosphere.vertex.glsl';
// @ts-expect-error - GLSL import
import starsFrag from './stars.fragment.glsl';
// @ts-expect-error - GLSL import
import starsVert from './stars.vertex.glsl';
// @ts-expect-error - GLSL import
import snowFrag from './snow_particle.fragment.glsl';
// @ts-expect-error - GLSL import
import snowVert from './snow_particle.vertex.glsl';
// @ts-expect-error - GLSL import
import rainFrag from './rain_particle.fragment.glsl';
// @ts-expect-error - GLSL import
import rainVert from './rain_particle.vertex.glsl';
// @ts-expect-error - GLSL import
import vignetteFrag from './vignette.fragment.glsl';
// @ts-expect-error - GLSL import
import vignetteVert from './vignette.vertex.glsl';
// @ts-expect-error - GLSL import
import occlusionFrag from './occlusion.fragment.glsl';
// @ts-expect-error - GLSL import
import occlusionVert from './occlusion.vertex.glsl';
// @ts-expect-error - GLSL import
import elevatedStructuresDepthReconstructFrag from '../../3d-style/shaders/elevated_structures_depth_reconstruct.fragment.glsl';
// @ts-expect-error - GLSL import
import elevatedStructuresDepthReconstructVert from '../../3d-style/shaders/elevated_structures_depth_reconstruct.vertex.glsl';
// @ts-expect-error - GLSL import
import elevatedStructuresDepthFrag from '../../3d-style/shaders/elevated_structures_depth.fragment.glsl';
// @ts-expect-error - GLSL import
import elevatedStructuresDepthVert from '../../3d-style/shaders/elevated_structures_depth.vertex.glsl';
// @ts-expect-error - GLSL import
import elevatedStructuresModelFrag from '../../3d-style/shaders/elevated_structures_model.fragment.glsl';
// @ts-expect-error - GLSL import
import elevatedStructuresModelVert from '../../3d-style/shaders/elevated_structures_model.vertex.glsl';
// 3d-style related shaders
// @ts-expect-error - GLSL import
import fillExtrusionDepthFrag from '../../3d-style/shaders/fill_extrusion_depth.fragment.glsl';
// @ts-expect-error - GLSL import
import fillExtrusionDepthVert from '../../3d-style/shaders/fill_extrusion_depth.vertex.glsl';
// @ts-expect-error - GLSL import
import groundShadowFrag from '../../3d-style/shaders/ground_shadow.fragment.glsl';
// @ts-expect-error - GLSL import
import groundShadowVert from '../../3d-style/shaders/ground_shadow.vertex.glsl';
// @ts-expect-error - GLSL import
import modelVert from '../../3d-style/shaders/model.vertex.glsl';
// @ts-expect-error - GLSL import
import modelFrag from '../../3d-style/shaders/model.fragment.glsl';
// @ts-expect-error - GLSL import
import modelDepthVert from '../../3d-style/shaders/model_depth.vertex.glsl';
// @ts-expect-error - GLSL import
import modelDepthFrag from '../../3d-style/shaders/model_depth.fragment.glsl';
// @ts-expect-error - GLSL import
import preludeShadowVert from '../../3d-style/shaders/_prelude_shadow.vertex.glsl';
// @ts-expect-error - GLSL import
import preludeShadowFrag from '../../3d-style/shaders/_prelude_shadow.fragment.glsl';

import type {ShaderSource} from '../render/program';
import type {DynamicDefinesType} from '../render/program/program_uniforms';

const commonDefines: DynamicDefinesType[] = [];
parseUsedPreprocessorDefines(preludeCommon, commonDefines);
parseUsedPreprocessorDefines(preludeVert, commonDefines);
parseUsedPreprocessorDefines(preludeFrag, commonDefines);

export const includeMap = {
    '_prelude_fog.vertex.glsl': preludeFogVert,
    '_prelude_terrain.vertex.glsl': preludeTerrainVert,
    '_prelude_shadow.vertex.glsl': preludeShadowVert,
    '_prelude_fog.fragment.glsl': preludeFogFrag,
    '_prelude_shadow.fragment.glsl': preludeShadowFrag,
    '_prelude_lighting.glsl': preludeLighting,
    '_prelude_raster_array.glsl': preludeRasterArrayFrag,
    '_prelude_raster_particle.glsl': preludeRasterParticleFrag
} as const;

// Populated during precompilation
const defineMap: Record<string, DynamicDefinesType[]> = {};

export const preludeTerrain = compile('', preludeTerrainVert);
export const preludeFog = compile(preludeFogFrag, preludeFogVert);
export const preludeShadow = compile(preludeShadowFrag, preludeShadowVert);
export const preludeRasterArray = compile(preludeRasterArrayFrag, '');
export const preludeRasterParticle = compile(preludeRasterParticleFrag, '');

export const prelude = compile(preludeFrag, preludeVert);
export const preludeCommonSource = preludeCommon;
export const preludeLightingSource = preludeLighting;

export const preludeVertPrecisionQualifiers = `precision highp float;`;
export const preludeFragPrecisionQualifiers = `precision mediump float;`;

export default {
    background: compile(backgroundFrag, backgroundVert),
    backgroundPattern: compile(backgroundPatternFrag, backgroundPatternVert),
    building: compile(buildingFrag, buildingVert),
    buildingDepth: compile(buildingDepthFrag, buildingDepthVert),
    circle: compile(circleFrag, circleVert),
    clippingMask: compile(clippingMaskFrag, clippingMaskVert),
    heatmap: compile(heatmapFrag, heatmapVert),
    heatmapTexture: compile(heatmapTextureFrag, heatmapTextureVert),
    collisionBox: compile(collisionBoxFrag, collisionBoxVert),
    collisionCircle: compile(collisionCircleFrag, collisionCircleVert),
    debug: compile(debugFrag, debugVert),
    elevatedStructuresDepth: compile(elevatedStructuresDepthFrag, elevatedStructuresDepthVert),
    elevatedStructuresDepthReconstruct: compile(elevatedStructuresDepthReconstructFrag, elevatedStructuresDepthReconstructVert),
    elevatedStructures: compile(elevatedStructuresModelFrag, elevatedStructuresModelVert),
    fill: compile(fillFrag, fillVert),
    fillOutline: compile(fillOutlineFrag, fillOutlineVert),
    fillOutlinePattern: compile(fillOutlinePatternFrag, fillOutlinePatternVert),
    fillPattern: compile(fillPatternFrag, fillPatternVert),
    fillExtrusion: compile(fillExtrusionFrag, fillExtrusionVert),
    fillExtrusionDepth: compile(fillExtrusionDepthFrag, fillExtrusionDepthVert),
    fillExtrusionPattern: compile(fillExtrusionPatternFrag, fillExtrusionPatternVert),
    groundShadow: compile(groundShadowFrag, groundShadowVert),
    fillExtrusionGroundEffect: compile(fillExtrusionGroundEffectFrag, fillExtrusionGroundEffectVert),
    hillshadePrepare: compile(hillshadePrepareFrag, hillshadePrepareVert),
    hillshade: compile(hillshadeFrag, hillshadeVert),
    line: compile(lineFrag, lineVert),
    linePattern: compile(linePatternFrag, linePatternVert),
    raster: compile(rasterFrag, rasterVert),
    rasterParticle: compile(rasterParticleFrag, rasterParticleVert),
    rasterParticleDraw: compile(rasterParticleDrawFrag, rasterParticleDrawVert),
    rasterParticleTexture: compile(rasterParticleTextureFrag, rasterParticleTextureVert),
    rasterParticleUpdate: compile(rasterParticleUpdateFrag, rasterParticleUpdateVert),
    symbol: compile(symbolFrag, symbolVert),
    terrainRaster: compile(terrainRasterFrag, terrainRasterVert),
    terrainDepth: compile(terrainDepthFrag, terrainDepthVert),
    skybox: compile(skyboxFrag, skyboxVert),
    skyboxGradient: compile(skyboxGradientFrag, skyboxVert),
    skyboxCapture: compile(skyboxCaptureFrag, skyboxCaptureVert),
    globeRaster: compile(globeFrag, globeVert),
    globeAtmosphere: compile(atmosphereFrag, atmosphereVert),
    model: compile(modelFrag, modelVert),
    modelDepth: compile(modelDepthFrag, modelDepthVert),
    stars: compile(starsFrag, starsVert),
    snowParticle: compile(snowFrag, snowVert),
    rainParticle: compile(rainFrag, rainVert),
    vignette: compile(vignetteFrag, vignetteVert),
    occlusion: compile(occlusionFrag, occlusionVert)
} as const;

export function parseUsedPreprocessorDefines(source: string, defines: DynamicDefinesType[]): void {
    const lines = source.replace(/\s*\/\/[^\n]*\n/g, '\n').split('\n');
    for (let line of lines) {
        line = line.trim();
        if (line[0] === '#') {
            if (line.includes('if') && !line.includes('endif')) {
                line = line.replace('#', '')
                    .replace(/ifdef|ifndef|elif|if/g, '')
                    .replace(/!|defined|\(|\)|\|\||&&/g, '')
                    .replace(/\s+/g, ' ').trim();

                const newDefines = line.split(' ') as DynamicDefinesType[];
                for (const define of newDefines) {
                    if (!defines.includes(define)) {
                        defines.push(define);
                    }
                }
            }
        }
    }
}

// Expand #pragmas to #ifdefs.
export function compile(fragmentSource: string, vertexSource: string): ShaderSource {
    const includeRegex = /#include\s+"([^"]+)"/g;
    const pragmaRegex = /#pragma mapbox: ([\w\-]+) ([\w]+) ([\w]+) ([\w]+)/g;
    const attributeRegex = /(attribute(\S*)|(^\s*|;)in) (highp |mediump |lowp )?([\w]+) ([\w]+)/gm;

    let staticAttributes: string[] = vertexSource.match(attributeRegex);

    if (staticAttributes) {
        staticAttributes = staticAttributes.map((str) => {
            const tokens = str.split(' ');

            return tokens[tokens.length - 1];
        });
        // remove duplicates as Safari does not support lookbehind in regex
        // so we need to get rid of initialize-* expressions
        staticAttributes = [...new Set(staticAttributes)];
    }
    const fragmentPragmas: Record<string, boolean> = {};

    const vertexIncludes = [];
    const fragmentIncludes = [];
    fragmentSource = fragmentSource.replace(includeRegex, (match, name) => {
        fragmentIncludes.push(name);
        return '';
    });
    vertexSource = vertexSource.replace(includeRegex, (match, name) => {
        vertexIncludes.push(name);
        return '';
    });

    if (vertexSource.includes("flat out")) {
        console.error(`The usage of "flat" qualifier is disallowed, see: https://bugs.webkit.org/show_bug.cgi?id=268071`);
        return;
    }

    let usedDefines: DynamicDefinesType[] = [...commonDefines];
    parseUsedPreprocessorDefines(fragmentSource, usedDefines);
    parseUsedPreprocessorDefines(vertexSource, usedDefines);
    for (const includePath of [...vertexIncludes, ...fragmentIncludes]) {
        if (!includeMap[includePath]) {
            console.error(`Undefined include: ${includePath}`);
        }
        if (!defineMap[includePath]) {
            defineMap[includePath] = [];
            parseUsedPreprocessorDefines(includeMap[includePath], defineMap[includePath]);
        }
        usedDefines = [...usedDefines, ...defineMap[includePath]];
    }

    fragmentSource = fragmentSource.replace(pragmaRegex, (match, operation, precision, type, name) => {
        fragmentPragmas[name] = true;
        if (operation === 'define') {
            return `
#ifndef HAS_UNIFORM_u_${name}
in ${precision} ${type} ${name};
#else
uniform ${precision} ${type} u_${name};
#endif
`;
        } else  if (operation === 'initialize') {
            return `
#ifdef HAS_UNIFORM_u_${name}
    ${precision} ${type} ${name} = u_${name};
#endif
`;
        } else if (operation === 'define-attribute') {
            return `
#ifdef HAS_ATTRIBUTE_a_${name}
    in ${precision} ${type} ${name};
#endif
`;
        } else if (operation === 'initialize-attribute') {
            return '';
        }

    });

    vertexSource = vertexSource.replace(pragmaRegex, (match, operation, precision, type, name) => {
        const attrType = type === 'float' ? 'vec2' : type;
        const unpackType = name.match(/color/) ? 'color' : attrType;

        if (operation === 'define-attribute-vertex-shader-only') {
            return `
#ifdef HAS_ATTRIBUTE_a_${name}
in ${precision} ${type} a_${name};
#endif
`;
        } else if (fragmentPragmas[name]) {
            if (operation === 'define') {
                return `
#ifndef HAS_UNIFORM_u_${name}
uniform lowp float u_${name}_t;
in ${precision} ${attrType} a_${name};
out ${precision} ${type} ${name};
#else
uniform ${precision} ${type} u_${name};
#endif
`;
            } else if (operation === 'initialize') {
                if (unpackType === 'vec4') {
                    // vec4 attributes are only used for cross-faded properties, and are not packed
                    return `
#ifndef HAS_UNIFORM_u_${name}
    ${name} = a_${name};
#else
    ${precision} ${type} ${name} = u_${name};
#endif
`;
                } else {
                    return `
#ifndef HAS_UNIFORM_u_${name}
    ${name} = unpack_mix_${unpackType}(a_${name}, u_${name}_t);
#else
    ${precision} ${type} ${name} = u_${name};
#endif
`;
                }
            } else if (operation === 'define-attribute') {
                return `
#ifdef HAS_ATTRIBUTE_a_${name}
    in ${precision} ${type} a_${name};
    out ${precision} ${type} ${name};
#endif
`;
            } else if (operation === 'initialize-attribute') {
                return `
#ifdef HAS_ATTRIBUTE_a_${name}
    ${name} = a_${name};
#endif
`;
            }
        } else {
            if (operation === 'define') {
                return `
#ifndef HAS_UNIFORM_u_${name}
uniform lowp float u_${name}_t;
in ${precision} ${attrType} a_${name};
#else
uniform ${precision} ${type} u_${name};
#endif
`;
            } else if (operation === 'define-instanced') {
                if (unpackType === 'mat4') {
                    return `
#ifdef INSTANCED_ARRAYS
in vec4 a_${name}0;
in vec4 a_${name}1;
in vec4 a_${name}2;
in vec4 a_${name}3;
#else
uniform ${precision} ${type} u_${name};
#endif
`;
                } else {
                    return `
#ifdef INSTANCED_ARRAYS
in ${precision} ${attrType} a_${name};
#else
uniform ${precision} ${type} u_${name};
#endif
`;
                }
            } else if (operation === 'initialize-attribute-custom') {
                return `
#ifdef HAS_ATTRIBUTE_a_${name}
    ${precision} ${type} ${name} = a_${name};
#endif
`;
            } else /* if (operation === 'initialize') */ {
                if (unpackType === 'vec4') {
                    // vec4 attributes are only used for cross-faded properties, and are not packed
                    return `
#ifndef HAS_UNIFORM_u_${name}
    ${precision} ${type} ${name} = a_${name};
#else
    ${precision} ${type} ${name} = u_${name};
#endif
`;
                } else /* */ {
                    return `
#ifndef HAS_UNIFORM_u_${name}
    ${precision} ${type} ${name} = unpack_mix_${unpackType}(a_${name}, u_${name}_t);
#else
    ${precision} ${type} ${name} = u_${name};
#endif
`;
                }
            }
        }
    });

    return {fragmentSource, vertexSource, staticAttributes, usedDefines, vertexIncludes, fragmentIncludes};
}
