// Protocol Version 1

package llmr.vector;

option optimize_for = LITE_RUNTIME;

enum geom_type {
    Unknown = 0;
    Point = 1;
    LineString = 2;
    Polygon = 3;
}

// Variant type encoding
message value {
    // Exactly one of these values may be present in a valid message
    optional string string_value = 1;
    optional float float_value = 2;
    optional double double_value = 3;
    optional int64 int_value = 4;
    optional uint64 uint_value = 5;
    optional sint64 sint_value = 6;
    optional bool bool_value = 7;

    extensions 8 to max;
}

message feature {
    optional uint64 id = 1;

    // Tags of this feature. Even numbered values refer to the nth
    // value in the keys list on the tile message, odd numbered
    // values refer to the nth value in the values list on the tile
    // message.
    repeated uint32 tags = 2 [ packed = true ];

    // The type of geometry stored in this feature.
    optional geom_type type = 3 [ default = Unknown ];

    // Contains a stream of commands and parameters (vertices). The
    // repeat count is shifted to the left by 3 bits. This means
    // that the command has 3 bits (0-15). The repeat count
    // indicates how often this command is to be repeated. Defined
    // commands are:
    // - MoveTo:    1   (2 parameters follow)
    // - LineTo:    2   (2 parameters follow)
    // - ClosePath: 15  (no parameters follow)
    //
    // Ex.: MoveTo(3, 6), LineTo(8, 12), LineTo(20, 34), ClosePath
    // Encoded as: [ 3 6 18 5 6 12 22 15 ]
    //                                == command type 15 (ClosePath)
    //                          ===== relative LineTo(+12, +22) == LineTo(20, 34)
    //                      === relative LineTo(+5, +6) == LineTo(8, 12)
    //                   == [00010 010] = command type 2 (LineTo), length 2
    //               === relative MoveTo(+3, +6)
    //             = implicit command type 1 (MoveTo), length 1
    // Commands are encoded as uint32 varints, vertex parameters are
    // encoded as sint32 varints (zigzag). Vertex parameters are
    // also encoded as deltas to the previous position. The original
    // position is (0,0)
    repeated uint32 geometry = 4 [ packed = true ];

    // A list of indices to the geometry array that specify a triangulation of
    // this geometry. This must only exist if this feature is a polygon.
    // These are the valid indices for the example above:
    //     0 ==>  (3/6)
    //     1 ==>  (8/12)
    //     2 ==> (20/34)
    // Indices beyond 2 are invalid, as the total number of vertices is 3.
    repeated sint32 triangulation = 5 [ packed = true ];

    // The total number of vertices encoded in the geometry field. This is can
    // be deduced by manually iterating through the geometry field, but we can
    // just as well store the number to avoid the overhead on parsing.
    optional uint32 vertex_count = 6;
}

// Stores a glyph with metrics and optional SDF bitmap information.
message glyph {
    required uint32 id = 1;

    // A signed distance field of the glyph with a border of 3 pixels.
    optional bytes bitmap = 2;

    // Glyph metrics.
    required uint32 width = 3;
    required uint32 height = 4;
    required sint32 left = 5;
    required sint32 top = 6;
    required uint32 advance = 7;
}

// Stores font face information and a list of glyphs.
message face {
    required string family = 1;
    required string style = 2;
    repeated glyph glyphs = 5;
}

// Stores the shaping information for the label with a given text
message label {
    // The original value ID this shaping information is for.
    required uint32 text = 1;

    // References the index of the font stack in the layer's fontstack array.
    required uint32 stack = 2;

    // Parallel arrays of face ID, glyph ID and position.
    repeated uint32 faces = 3  [packed = true];
    repeated uint32 glyphs = 4 [packed = true];
    repeated uint32 x = 5  [packed = true];
    repeated uint32 y = 6  [packed = true];
}

message layer {
    // Any compliant implementation must first read the version
    // number encoded in this message and choose the correct
    // implementation for this version number before proceeding to
    // decode other parts of this message.
    required uint32 version = 15 [ default = 1 ];

    required string name = 1;

    // The actual features in this tile.
    repeated feature features = 2;

    // Dictionary encoding for keys
    repeated string keys = 3;

    // Dictionary encoding for values
    repeated value values = 4;

    // The bounding box in this tile spans from 0..4095 units
    optional uint32 extent = 5 [ default = 4096 ];

    // Total vertex count in this layer.
    optional uint32 vertex_count = 6;

    // Shaping information for labels contained in this tile.
    repeated string faces = 7;
    repeated label labels = 8;
    repeated string stacks = 9;

    extensions 16 to max;
}

message tile {
    repeated layer layers = 3;

    repeated face faces = 4;

    extensions 16 to 8191;
}
